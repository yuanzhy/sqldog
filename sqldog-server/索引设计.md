## 数据索引简单设计

### 文件名称：[字段名]$$[index]

### 页结构 16K
| 名称            | 中文名  | 占用空间大小 | 简单描述      |
|---------------|------|--------|-----------|
| Page Header   | 页面头部 | 9字节+   | 页专有的一些信息  |
| Index Records | 索引记录 | -      | 实际存储的索引内容 |
| Free Space    | 空闲空间 | -      | 页中尚未使用的空间 |

### Page Header
| 名称         | 占用空间 | 描述                                 |
|------------|------|------------------------------------|
| CHKSUM     | 4字节  | 页的校验和（checksum值）                   |
| FREE_START | 2字节  | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space |
| FREE_END   | 2字节  | 还未使用的空间最大地址，也就是说从该地址之前就是Free Space |
| LEVEL      | 1字节  | 层级，0表示叶子节点，其中第一位表示是否是叶子            |
| PREV_PAGE  | 4字节  | 上一页地址值，叶子节点有此属性                    |
| NEXT_PAGE  | 4字节  | 下一页地址值，叶子节点有此属性                    |

### Index Records
- 树枝索引按照[值-索引地址值]的形式有序存储，索引地址4字节，其中2字节表示索引文件id，2字节表示页偏移
- 叶子索引按照[值-LEN-多个数据地址值]的形式有序存储，数据地址8字节，其中2字节表示数据文件id，2字节表示页偏移，2字节表示offset，2字节表示length，其中LEN 4字节表示后面地址值有多少个，如果地址值超过一页，则通过NEXT_PAGE的下一页继续存储[多个数据地址值]
- 查询：通过树枝索引的值区间（可能需要多级跳转）找到叶子索引，定位到对应的页，遍历页数据找到记录对应的源表地址，回表取出记录
- 插入：插入一个值重新排列此页，如果页不够存放数据，则新开一个页同时上一层需要插入一个值并新开一页，根节点也要更新下。当根节点页满了需要新加一个页重排索引并向上扩充一个层级，此时B树的层级+1
- 其中 值 前两位代表后面的长度，为了简单处理，目前的实现是定长类型和变成类型都带长度了
